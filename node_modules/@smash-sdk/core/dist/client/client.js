"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const config_1 = require("../config/config");
const sdkError_1 = require("../errors/sdkError");
const http_1 = require("../http");
class Client {
    constructor(params) {
        this.service = params.service;
        this.client = params.client || new http_1.AxiosClient();
        this.token = params.token ? params.token : config_1.config.getToken();
        this.region = params.region ? params.region : config_1.config.getRegion();
        this.host = params.host ? params.host : config_1.config.getHost(this.service, this.region);
        if (params.refreshTokenMethod) {
            this.refreshTokenMethod = this.buildRefreshTokenMethod(params.refreshTokenMethod);
        }
    }
    parseResponse(response, errors) {
        var _a;
        if (this.isValidStatusCode(response.statusCode)) {
            return response.body ? response.body : {};
        }
        else if (((_a = response === null || response === void 0 ? void 0 : response.body) === null || _a === void 0 ? void 0 : _a.name) && errors[(response === null || response === void 0 ? void 0 : response.body).name]) {
            const body = response === null || response === void 0 ? void 0 : response.body;
            const error = new errors[(response === null || response === void 0 ? void 0 : response.body).name](body);
            throw error;
        }
        else {
            throw new sdkError_1.UnknownError(response === null || response === void 0 ? void 0 : response.body);
        }
    }
    isValidStatusCode(code) {
        return code >= 200 && code < 300;
    }
    buildRefreshTokenMethod(refreshTokenMethod) {
        return (error, retries = 0) => {
            return new Promise(async (resolve, reject) => {
                try {
                    const token = await refreshTokenMethod(error, retries);
                    if (token) {
                        this.token = token;
                    }
                    resolve(token);
                }
                catch (error) {
                    reject(error);
                }
            });
        };
    }
}
exports.Client = Client;
