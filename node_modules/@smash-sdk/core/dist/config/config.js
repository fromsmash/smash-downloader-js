"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.config = exports.Config = void 0;
const sdkError_1 = require("../errors/sdkError");
const index_1 = require("./types/index");
;
class Config {
    constructor() {
        this.hosts = {};
        if (isNode()) {
            if (process === null || process === void 0 ? void 0 : process.env) {
                if (process === null || process === void 0 ? void 0 : process.env[index_1.SmashEnvRegion]) {
                    this.setRegion(process.env[index_1.SmashEnvRegion]);
                }
                if (process === null || process === void 0 ? void 0 : process.env[index_1.SmashEnvToken]) {
                    this.setToken(process.env[index_1.SmashEnvToken]);
                }
            }
        }
    }
    static get Instance() {
        if (isNode()) {
            if (!global.smashSdkConfig) {
                Config.instance = new Config();
                global.smashSdkConfig = Config.instance;
            }
            Config.instance = global.smashSdkConfig;
        }
        else {
            if (!window.smashSdkConfig) {
                Config.instance = new Config();
                window.smashSdkConfig = Config.instance;
            }
            Config.instance = window.smashSdkConfig;
        }
        return Config.instance;
    }
    getHost(service, region = "global") {
        if (region === "global") {
            return this.hosts[service][region];
        }
        else if (this.hosts[service][region]) {
            return this.hosts[service][region];
        }
        else {
            throw new sdkError_1.SDKError("Invalid region asked: " + region + " for service " + service + ", available regions are " + Object.keys(this.hosts[service]).join(", ") + ".");
        }
    }
    setHosts(service, hosts) {
        this.hosts[service] = hosts;
    }
    setRegion(region) {
        this.region = region;
    }
    getRegion() {
        return this.region;
    }
    setToken(token) {
        this.token = token;
    }
    getToken() {
        return this.token;
    }
}
exports.Config = Config;
let cachedIsNode;
let called = false;
const detect = new Function('try {return this===global;}catch(e){return false;}');
function isNode() {
    if (called) {
        return cachedIsNode;
    }
    cachedIsNode = detect();
    called = true;
    return cachedIsNode;
}
exports.config = Config.Instance;
